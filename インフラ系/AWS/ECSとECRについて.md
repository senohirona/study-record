# ECSの用語について
- (個人的に)なかなか理解できなかったので記載しておく
- 記載する内容は下記
    - クラスター
    - タスク定義
    - サービス

## クラスター
- dockerコンテナを実行するためのホストPCのようなもの
    - 例:自分のmac
- 現時点(2018-11-13)時点で下記3種類が作成できる
    - ネットワーキングのみ
    - EC2Linux+ネットワーキング
    - EC2Windows+ネットワーキング
- EC2Linux/EC2WindowsはそれぞれのOSでコンテナを利用するためのツールが入ったイメージを使ってEC2を作成する
    - macはライセンス上使えない
- なぜ、OS別に別れてるのか？
    - windows/linuxでしか動かないアプリケーション存在しているため
        - windowsとlinuxはそれぞれ別の仕組みで動いているのに起因

## タスク定義
- dockerコンテナの設定をしている部分(docker-composeの設定もここでやっている)
    - どんなイメージを使うのか
    - メモリやCPUはいくつ使うのか
    - ENVの定義
    - ポートの指定

## サービス
- 「どうクラスタにデプロイするのか?」の設定を書く
    - タスク定義で設定したものをクラスタで実行させる部分
- LBの設定や、IAMの設定をここで行うことができる

# ECRについて
- 正式名称「Amazon Elastic Container Registry」
    - [公式ドキュメント](https://docs.aws.amazon.com/ja_jp/AmazonECR/latest/userguide/what-is-ecr.html)
- dockerイメージを保存しておくためのレジストリ
- ECRに保存したdockerイメージは、EC2などのサービスにデプロイすることができる

## 疑問点

### イメージを置いてある場所といえばdocker hub等があるが、それとは何が違うのか？
- docker hubに置かれているイメージは「**外部公開しても良いもの**」が置かれている
    - 外部公開できないものはdocker hub等においてはいけない
- ECRの場合は「このユーザーからでないとpullが出来ない」と言った設定ができるため、外部公開できないイメージを置いておくことができる


### githubにはdockerfileがあるが、それとは何が違うのか？

- dockerfileは`docker build`する必要があるが、dockerイメージがあればわざわざ`build`しなくても良い
- 例: アプリを利用するときに、「storeからアプリを落とす」必要はあるが、「アプリのソースコードはなくてもアプリは利用できる」というのと同じ

# 作業
### 手順
- 実際に触ってみる(ECS)
    - コンテナを立ててみる
        - タスク定義を設定する
    - タスク定義を更新する
    - ECSを利用する
        - dockerimageの構築
        - タグ付け
        - push
- ECRも実際に触って確認してみる

## コンテナを立ててみる
- awsチュートリアルを参考に実際にコンテナを立ててみる
    - [チュートリアル](https://aws.amazon.com/jp/getting-started/tutorials/deploy-docker-containers/?trk=gs_card)
- 公式以外でもチュートリアル(っぽいもの)を作っている人がいた
    - [Amazon ECS入門 〜公式のDockerイメージを使って10分で構築してみる〜
](https://dev.classmethod.jp/cloud/aws/amazon-ecs-entrance-1)

### クラスターを作る

- 今回は「ネットワーキングのみ」を利用する
- VPCは今回設定しない
- 出来た

### タスク定義を作成する

- 「起動タイプの互換性の選択」でfargateを選択する
    - 起動タイプ:fargateで起動するか、EC2できそうするか
    - **注意: クラスターでfagateを作った場合はfagateのタスク定義を作成しなければならない**
- タスクとコンテナの定義の設定
    - タスクロールは「なし」
        - タスクロール:awsの各種サービスにアクセスする権限
    - タスクサイズは最小のやつを選択
- コンテナの追加
    - イメージは「nginx:latest」
    - プライベートリポジトリーの認証は「なし」
    - メモリ制限は「ソフト制限」「128」
    - ポートマッピングは「80(nginxのデフォルト値)」「tcp」
    - 「詳細コンテナ設定」は今回設定しない
- 「作成」押す

### サービスを作る

- クラスターの「サービス作成」を押す
- サービスの設定
    - 起動タイプ:fargate
    - タスク定義
        - family: 自分が作ったタスク定義名のもの
        - Rebision: 1
        - プラットフォームのバージョン: latest
        - タスクの数:タスク定義をいくつ実行するか
        - 後の設定は気にしない
- ネットワーク構成
    - VPCとセキュリティグループ
        - クラスターVPC:あったやつを利用する
        - サブネット: あったやつを利用する
        - セキュリティグループ: インバウントのポートが80になっているか確認
        - パブリックIPの自動割当: ENABLED
- ELB(オプション)
    - なし
- サービスの検出(オプション)
    - 無効化
- Auto Scaling
    - サービスを必要数を直接調整しないを選択
    - 今回は使用しないため
- 「サービスの作成」を押す
- クラスター -> タスク-> Public IP にアクセスする(今回は  13.231.200.246)
    - 作成したサービスが閲覧できる

## ECRを触ってみる
- タスク定義の更新前に作成したタスク(dockerコンテナ)を保存してみる

### リポジトリを作成する

- ECSの左のメニューから「リポジトリ」を選択する
- 「リポジトリの作成」ボタンがあるので、押す


### dockerイメージをpushする

- リポジトリを作成すると、「プッシュコマンドの表示」という物が見られるように唸るので、それを参考にpushしていく
- 事前にdockerfike(中身は何でも構わない)をローカル環境に用意しておく必要がある
    - 今回は、以前docker本で作ったgoのdockerfileをpushする
- pushする際、aws configureで、アクセスキー達がリポジトリを作成したawsアカウントかを確認する
    - 違うアカウントの場合pushが失敗する
- 違っていた場合は、`aws configure`でアクセスキー達を設定し直してからもう一度ログインコマンドをし直す
- pushに成功したら、コンソール画面からリポジトリにイメージが入っているか確認する
- 入っていたら終わり

pushログ
```
zsh
$ docker push <中略>.amazonaws.com/test-ecs/test:latest
The push refers to repository [<中略>amazonaws.com/seno/test]
1159ce8c96f4: Pushed
1d47ebe64f47: Pushed
186d94bd2c62: Pushed
24a9d20e5bee: Pushed
e7dc337030ba: Pushed
920961b94eb3: Pushed
fa0c3f992cbd: Pushed
ce6466f43b11: Pushed
719d45669b35: Pushed
3b10514a95be: Pushed
latest: digest: sha256:f84dd1b03b5b8d2f6ce7e2e409f96bf17c1499cacaa3ba108351a49882d81dd1 size: 2417
```

## タスク定義を更新する

- 今回は下記を参考に行った
    - [Amazon ECS でコンテナをローリングアップデートする](https://qiita.com/NaokiIshimura/items/8e43135864f2518dcabc)
- 今回のゴールは、nginxからgoのwebサーバーに変更する
    - nginxの画面から「Hello Docker!!」の画面になればok

- ECSの「タスク定義」から自分が作成したタスク定義->今回変更するタスク定義にチェックを入れる
- 「新しいリビジョン」を押す
- 「コンテナの定義」に「コンテナ名」というカラムがあるので、そこ記載されているコンテナをクリック
- コンテナの編集画面が出るので「イメージ」をECRに保存されているイメージのURIに変更する
    - URIはリポジトリに記載されいる
    - 複数保存していた場合は、URLの一番最後にタグをつける
    - ポートは「8080」に変更(goのwebサーバーのポート設定の関係上)
- 「更新」を押す

## 更新したタスク定義をクラスターにデプロイする
- クラスターの「サービス」タブで自分のサービスを選択
- 「更新」ボタンを押す
- 「サービスの設定」画面の「Revision」を変更する
- 後の部分はいじらず「次のステップ」->「サービスの更新」ボタンを押す
- しばらくすると、更新したサービスが立ち上がる
- サービスのパブリックIPにアクセスして自分が想定したものになっているのを確認する
- ※: 別途VPCで設定するポート番号を追加する必要がある
